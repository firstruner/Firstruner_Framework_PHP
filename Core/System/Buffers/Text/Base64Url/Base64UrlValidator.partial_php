<?php

/**
 * Copyright since 2024 Firstruner and Contributors
 * Firstruner is an Registered Trademark & Property of Christophe BOULAS
 *
 * NOTICE OF LICENSE
 *
 * This source file is subject to the Freemium License
 * If you did not receive a copy of the license and are unable to
 * obtain it through the world-wide-web, please send an email
 * to contact@firstruner.fr so we can send you a copy immediately.
 *
 * DISCLAIMER
 *
 * Do not edit, reproduce ou modify this file.
 * Please refer to https://firstruner.fr/ or contact Firstruner for more information.
 *
 * @author    Firstruner and Contributors <contact@firstruner.fr>
 * @copyright Since 2024 Firstruner and Contributors
 * @license   Proprietary
 * @version 2.0.0
 */

//namespace System\Buffers\Text;

//use System\Runtime\CompilerServices;
use System\Attributes\Partial;

#[Partial()]
class Base64Url
{
//     /// <summary>Validates that the specified span of text is comprised of valid base-64 encoded data.</summary>
//     /// <param name="base64UrlText">A span of text to validate.</param>
//     /// <returns><see langword="true"/> if <paramref name="base64UrlText"/> contains a valid, decodable sequence of base-64 encoded data; otherwise, <see langword="false"/>.</returns>
//     /// <remarks>
//     /// If the method returns <see langword="true"/>, the same text passed to <see cref="Base64Url.DecodeFromChars(ReadOnlySpan{char})"/> and
//     /// <see cref="Base64Url.TryDecodeFromChars(ReadOnlySpan{char}, Span{byte}, out int)"/> would successfully decode (in the case
//     /// of <see cref="Base64Url.TryDecodeFromChars(ReadOnlySpan{char}, Span{byte}, out int)"/> assuming sufficient output space).
//     /// Any amount of whitespace is allowed anywhere in the input, where whitespace is defined as the characters ' ', '\t', '\r', or '\n'.
//     /// </remarks>
//     public static function IsValid(ReadOnlySpan<char> $base64UrlText) : bool
//     {
//         Base64Helper.IsValid(default(Base64UrlCharValidatable), base64UrlText, out _);
//     }

//     /// <summary>Validates that the specified span of text is comprised of valid base-64 encoded data.</summary>
//     /// <param name="base64UrlText">A span of text to validate.</param>
//     /// <param name="decodedLength">If the method returns true, the number of decoded bytes that will result from decoding the input text.</param>
//     /// <returns><see langword="true"/> if <paramref name="base64UrlText"/> contains a valid, decodable sequence of base-64 encoded data; otherwise, <see langword="false"/>.</returns>
//     /// <remarks>
//     /// If the method returns <see langword="true"/>, the same text passed to <see cref="Base64Url.DecodeFromChars(ReadOnlySpan{char})"/> and
//     /// <see cref="Base64Url.TryDecodeFromChars(ReadOnlySpan{char}, Span{byte}, out int)"/> would successfully decode (in the case
//     /// of <see cref="Base64Url.TryDecodeFromChars(ReadOnlySpan{char}, Span{byte}, out int)"/> assuming sufficient output space).
//     /// Any amount of whitespace is allowed anywhere in the input, where whitespace is defined as the characters ' ', '\t', '\r', or '\n'.
//     /// </remarks>
//     public static bool IsValid(ReadOnlySpan<char> base64UrlText, out int decodedLength) =>
//         Base64Helper.IsValid(default(Base64UrlCharValidatable), base64UrlText, out decodedLength);

//     /// <summary>Validates that the specified span of UTF-8 text is comprised of valid base-64 encoded data.</summary>
//     /// <param name="utf8Base64UrlText">A span of UTF-8 text to validate.</param>
//     /// <returns><see langword="true"/> if <paramref name="utf8Base64UrlText"/> contains a valid, decodable sequence of base-64 encoded data; otherwise, <see langword="false"/>.</returns>
//     /// <remarks>
//     /// where whitespace is defined as the characters ' ', '\t', '\r', or '\n' (as bytes).
//     /// </remarks>
//     public static bool IsValid(ReadOnlySpan<byte> utf8Base64UrlText) =>
//         Base64Helper.IsValid(default(Base64UrlByteValidatable), utf8Base64UrlText, out _);

//     /// <summary>Validates that the specified span of UTF-8 text is comprised of valid base-64 encoded data.</summary>
//     /// <param name="utf8Base64UrlText">A span of UTF-8 text to validate.</param>
//     /// <param name="decodedLength">If the method returns true, the number of decoded bytes that will result from decoding the input UTF-8 text.</param>
//     /// <returns><see langword="true"/> if <paramref name="utf8Base64UrlText"/> contains a valid, decodable sequence of base-64 encoded data; otherwise, <see langword="false"/>.</returns>
//     /// <remarks>
//     /// where whitespace is defined as the characters ' ', '\t', '\r', or '\n' (as bytes).
//     /// </remarks>
//     public static bool IsValid(ReadOnlySpan<byte> utf8Base64UrlText, out int decodedLength) =>
//         Base64Helper.IsValid(default(Base64UrlByteValidatable), utf8Base64UrlText, out decodedLength);

//     private const uint UrlEncodingPad = '%'; // allowed for url padding

//     private readonly struct Base64UrlCharValidatable : Base64Helper.IBase64Validatable<char>
//     {
// #if NET
//         private static readonly SearchValues<char> s_validBase64UrlChars = SearchValues.Create("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_");

//         public int IndexOfAnyExcept(ReadOnlySpan<char> span) => span.IndexOfAnyExcept(s_validBase64UrlChars);
// #else
//         public int DecodeValue(char value)
//         {
//             if (value > byte.MaxValue)
//             {
//                 // Invalid char was found.
//                 return -2;
//             }

//             return default(Base64UrlDecoderByte).DecodingMap[value];
//         }
// #endif
//         public bool IsWhiteSpace(char value) => Base64Helper.IsWhiteSpace(value);
//         public bool IsEncodingPad(char value) => value == Base64Helper.EncodingPad || value == UrlEncodingPad;
//         [MethodImpl(MethodImplOptions.AggressiveInlining)]
//         public bool ValidateAndDecodeLength(int length, int paddingCount, out int decodedLength) =>
//             default(Base64UrlByteValidatable).ValidateAndDecodeLength(length, paddingCount, out decodedLength);
//     }

//     private readonly struct Base64UrlByteValidatable : Base64Helper.IBase64Validatable<byte>
//     {
// #if NET
//         private static readonly SearchValues<byte> s_validBase64UrlChars = SearchValues.Create(default(Base64UrlEncoderByte).EncodingMap);

//         public int IndexOfAnyExcept(ReadOnlySpan<byte> span) => span.IndexOfAnyExcept(s_validBase64UrlChars);
// #else
//         public int DecodeValue(byte value) => default(Base64UrlDecoderByte).DecodingMap[value];
// #endif
//         public bool IsWhiteSpace(byte value) => Base64Helper.IsWhiteSpace(value);
//         public bool IsEncodingPad(byte value) => value == Base64Helper.EncodingPad || value == UrlEncodingPad;
//         [MethodImpl(MethodImplOptions.AggressiveInlining)]
//         public bool ValidateAndDecodeLength(int length, int paddingCount, out int decodedLength)
//         {
//             // Padding is optional for Base64Url, so need to account remainder. If remainder is 1, then it's invalid.
// #if NET
//             (uint whole, uint remainder) = uint.DivRem((uint)(length), 4);
//             if (remainder == 1 || (remainder > 1 && (remainder - paddingCount == 1 || paddingCount == remainder)))
//             {
//                 decodedLength = 0;
//                 return false;
//             }

//             decodedLength = (int)((whole * 3) + (remainder > 0 ? remainder - 1 : 0) - paddingCount);
// #else
//             int remainder = (int)((uint)length % 4);
//             if (remainder == 1 || (remainder > 1 && (remainder - paddingCount == 1 || paddingCount == remainder)))
//             {
//                 decodedLength = 0;
//                 return false;
//             }

//             decodedLength = (length >> 2) * 3 + (remainder > 0 ? remainder - 1 : 0) - paddingCount;
// #endif
//             return true;
//         }
//     }
}
